<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <script src="..\js\d3.min.js"></script>
    <script src="..\js\color_conversion.js"></script>
</head>
<body>
    <canvas id="canvas_hc"></canvas>
    <canvas id="canvas_hl"></canvas>
    <canvas id="canvas_lc"></canvas>
    <hr />
    L: <input id="input_l" type="number" step="1" /><br />
    C: <input id="input_c" type="number" step="1" /><br />
    H: <input id="input_h" type="number" step="1" /><br />

</body>

<script>

// <input id="input_l" type="number" />要求有以下功能, Banker's Rounding

// 绘图精度
let res_l = 256;   // l
let res_c = 256;   // c
let res_h = 256;   // h     数据范围: [0, res_h - 1]
let ab_max= .324;

// 定义域
let domain_l_max = 100;
let domain_c_max = 100;
let domain_h_max = 360;
let scale_l_input = d3.scaleLinear([0, domain_l_max], [0, res_l-1]);
let scale_c_input = d3.scaleLinear([0, domain_c_max], [res_c-1, 0]); // * 需要颠倒第二个轴的值
let scale_h_input = d3.scaleLinear([0, domain_h_max], [0, res_h-1]);
//默认值
d3.select("#input_l").property("value", 0.5*domain_l_max);
d3.select("#input_c").property("value", 0.5*domain_c_max);
d3.select("#input_h").property("value", 0.5*domain_h_max);

// 色彩溢出部分的透明度 [0, 255]
let displayable_color_alpha = 85;

// 获取画面元素
var canvas_hc = document.getElementById("canvas_hc");
canvas_hc.width = res_h;
canvas_hc.height = res_c;
var ctx_hc = canvas_hc.getContext("2d");
var image_hc = ctx_hc.createImageData(canvas_hc.width, canvas_hc.height);

var canvas_hl = document.getElementById("canvas_hl");
canvas_hl.width = res_h;
canvas_hl.height = res_l;
var ctx_hl = canvas_hl.getContext("2d");
var image_hl = ctx_hl.createImageData(canvas_hl.width, canvas_hl.height);

var canvas_lc = document.getElementById("canvas_lc");
canvas_lc.width = res_l;
canvas_lc.height = res_c;
var ctx_lc = canvas_lc.getContext("2d");
var image_lc = ctx_lc.createImageData(canvas_lc.width, canvas_lc.height);

// 获取输入元素
let input_l = document.getElementById('input_l');
let input_c = document.getElementById('input_c');
let input_h = document.getElementById('input_h');

//=====================================  =====================================//
//                              预先计算色彩空间                              //
//=====================================  =====================================//

// lch 色彩空间 数组 ( 横坐标 为 h, 纵坐标 为 c, 深度 为 l )
let colorspace_lch = new Uint8ClampedArray(res_h * res_c * res_l * 4);
let scale_h = d3.scaleLinear([0, res_h], [0, 2*Math.PI]);
let scale_c = d3.scaleLinear([0, res_c], [ab_max, 0]);
// lch 色彩空间 向 sRGB映射
{
for (let l = 0; l < res_l; l++) {
for (let c = 0; c < res_c; c++) {
for (let h = 0; h < res_h; h++) {
    let index = (h + c*res_h + l*res_h*res_c) * 4;
    let color = oklrch_to_srgb([l/res_l, scale_c(c), scale_h(h)])
    colorspace_lch[index    ] = color[0]*255; // 红
    colorspace_lch[index + 1] = color[1]*255; // 绿
    colorspace_lch[index + 2] = color[2]*255; // 蓝
    colorspace_lch[index + 3] = d3rgb(color).displayable() ? 255 : displayable_color_alpha; // 不透明度
}}}
}
//=====================================  =====================================//
//                               读取数据与绘图                               //
//=====================================  =====================================//

let colorspace_hc = new Uint8ClampedArray(res_h*res_c*4);
function draw_hc(l) {
    l = parseInt(scale_l_input(l));
    for (let c = 0; c < res_c; c++) {       // y 轴
    for (let h = 0; h < res_h; h++) {       // x 轴
    for (let i = 0; i < 4    ; i++) {       // 通道
        let index = (h + c*res_h + l*res_h*res_c) * 4;  // 坐标
        colorspace_hc[i + h*4 + c*res_h*4] = colorspace_lch[index + i];
    }}}
    image_hc.data.set(colorspace_hc);       // 数组 -> 图像数据
    ctx_hc.putImageData(image_hc, 0, 0);    // 绘图
}
draw_hc(parseInt(input_l.value));           // 初始化

let colorspace_hl = new Uint8ClampedArray(res_h*res_l*4);
function draw_hl(c) {
    c = parseInt(scale_c_input(c));
    for (let l = 0; l < res_l; l++) {
    for (let h = 0; h < res_h; h++) {
    for (let i = 0; i < 4    ; i++) {
        let index = (h + c*res_h + l*res_h*res_c) * 4;
        colorspace_hl[i + h*4 + (res_l-l)*res_h*4] = colorspace_lch[index + i];
    }}}
    image_hl.data.set(colorspace_hl);
    ctx_hl.putImageData(image_hl, 0, 0);
}
draw_hl(parseInt(input_c.value));

let colorspace_lc = new Uint8ClampedArray(res_h*res_c*4);
function draw_lc(h) {
    h = parseInt(scale_h_input(h));
    for (let c = 0; c < res_c; c++) {
    for (let l = 0; l < res_l; l++) {
    for (let i = 0; i < 4    ; i++) {
        let index = (h + c*res_h + l*res_h*res_c) * 4;
        colorspace_lc[i + l*4 + c*res_h*4] = colorspace_lch[index + i];
    }}}
    image_lc.data.set(colorspace_lc);
    ctx_lc.putImageData(image_lc, 0, 0);
}
draw_lc(parseInt(input_h.value));

//=====================================  =====================================//
//                                监听  输入框                                //
//=====================================  =====================================//
input_l.addEventListener('change', function() {
    const value = parseInt(this.value);
    draw_hc(value);
    }
);

// input_c.addEventListener('input', function() {
//     const value = parseInt(this.value);
//     if (isNaN(value) || value >= res_c || value < 0) {  // 非数字 最大值 最小值
//         this.value = '';
//     } else {
//         this.value = value;
//     }
// });

input_c.addEventListener('change', function() {
    const value = parseInt(this.value);
    draw_hl(value);
    }
);
input_h.addEventListener('change', function() {
    const value = parseInt(this.value);
    draw_lc(value);
});

//=====================================  =====================================//
//                                    测试                                    //
//=====================================  =====================================//
var myNumber = 42;
var svg = d3.select("body").append("svg")
  .attr("width", 500)
  .attr("height", 500);
var text = svg.append("text")
  .attr("x", 50)
  .attr("y", 50)
  .text(myNumber);

</script>

</html>